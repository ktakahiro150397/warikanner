割り勘アプリのフロントエンド、バックエンド（オフチェーン）、スマートコントラクト（オンチェーン）が持つべき実装と役割を、図とテキストで整理します。

### 割り勘アプリの全体アーキテクチャ図

```mermaid
graph TD
    subgraph Frontend (ブラウザ上で動作)
        A[UI/UX]
        B[ウォレット接続]
        C[EIP-681 リンク生成]
        D[スマートコントラクト対話]
        E[履歴表示 (The Graph)]
    end

    subgraph Backend (従来のサーバー - オプション)
        F[ユーザー通知]
        G[複雑な計算]
    end

    subgraph Smart Contract (ブロックチェーン上)
        H[データ構造: Invoice]
        I[状態管理: 請求台帳 Mapping]
        J[関数: 請求作成]
        K[関数: 支払い実行]
        L[イベント: 支払い完了通知]
    end

    A --> B
    A --> C
    B --> D
    D <--> J
    D <--> K
    E --> A
    
    C --> F
    
    J --> I
    K --> I
    K --> L

    linkStyle 7 stroke:#ff9900,stroke-width:2px;
    linkStyle 8 stroke:#ff9900,stroke-width:2px;
    linkStyle 9 stroke:#ff9900,stroke-width:2px;
    linkStyle 10 stroke:#ff9900,stroke-width:2px;

```

-----

### ① フロントエンド (Next.js / React)

ユーザーが直接触れる部分です。快適なUXを提供することが主な責務です。

  * **UI/UX (画面)**

      * 割り勘のメンバーや金額を入力するフォーム。
      * 自分宛ての未払い請求一覧。
      * 過去の支払い履歴。

  * **ウォレット接続 (ethers.js)**

      * MetaMaskなどのウォレットをWebサイトに接続する機能。
      * 接続中のユーザーアドレスやネットワーク（Polygonなど）を取得・表示する。

  * **EIP-681 支払いリンク生成**

      * 立替者が支払者に支払いを要求するためのリンクやQRコードを生成する。
      * 内容はスマートコントラクトの`payInvoice(invoiceId)`関数を指すように動的に作成する。

  * **スマートコントラクトとの対話 (ethers.js)**

      * **書き込み処理**:
          * `createInvoice`関数を呼び出して、新しい請求を作成する。
          * ERC-20トークンの`approve`をユーザーに促す。
          * `payInvoice`関数を呼び出して、請求に対する支払いを行う。
      * **読み取り処理**:
          * スマートコントラクトの`invoices(invoiceId)`を呼び出し、特定の請求情報を取得する。

  * **支払い履歴の表示 (The Graph)**

      * The GraphのAPIに問い合わせ（GraphQL）、過去の支払い履歴（自分関連、グループ全体など）を高速に取得して一覧表示する。

-----

### ② スマートコントラクト (Solidity)

アプリの心臓部であり、**信頼の根幹**です。お金の移動に関するルールを厳格に実行します。

  * **データ構造 (`struct Invoice`)**

      * 単一の請求情報を定義する設計図。
      * **保持するデータ**: ユニークID, 支払者アドレス, 受取人アドレス, 金額, 支払いステータス(`isPaid`)。

  * **状態管理 (`mapping`)**

      * 全ての請求情報を格納する台帳。
      * 請求IDをキーとして、いつでも特定の請求データを読み書きできる。

  * **関数: 請求作成 (`createInvoice`)**

      * 新しい請求情報を受け取り、台帳に記録する関数。
      * 主に立替者（受取人）によって呼び出される。

  * **関数: 支払い実行 (`payInvoice`)**

      * 支払者が請求IDを指定して呼び出す関数。
      * **内部処理**:
        1.  請求IDが存在し、未払いであることを確認。
        2.  呼び出し人が正規の支払者であることを確認。
        3.  `transferFrom`で支払者から指定額のトークンをコントラクトへ移動。
        4.  トークンを受取人へ転送。
        5.  請求ステータスを`isPaid = true`に更新。
        6.  後述のイベントを発生させる。

  * **イベント (`event PaymentCompleted`)**

      * 支払いが正常に完了したことをブロックチェーン上に記録するログ。
      * The Graphなどの外部サービスがこのイベントを検知して、履歴データベースを更新する。

-----

### ③ バックエンド (従来のサーバー - オプション)

このアーキテクチャでは、バックエンドは補助的な役割に留まります。**必須ではありません**が、あるとUXを向上できます。

  * **ユーザー通知**

      * 新しい請求が作成された際に、支払者に対してメールやPush通知を送る。
      * ブロックチェーンは外部に能動的に通知できないため、この部分はオフチェーンの得意分野。

  * **複雑な計算**

      * 非常に複雑な割り勘ロジック（大人数での貸し借りを相殺するなど）が必要な場合、ガス代を節約するためにオフチェーンで計算し、最終結果だけをスマートコントラクトに渡す。
      * ただし、今回の要件では不要でしょう。